#' Parse times from a template of the structure generated by
#' \code{\link{yaml_template}}
#'
#' @param times A list, based on the structure generated by
#' \code{\link{yaml_template}}
#' @param returnIntermediateTable Return a day-by-day summary table.
#'
#' @return If returnIntermediateTable is FALSE, a summary tibble, with three columns:
#'    1. deficit: Whether the total represents a deficit of total time after
#'                comparing to day-by-day targetDurations and the overall
#'                starting timelog totals.
#'    2. hours:   The number of hours.
#'    3. minutes: The number of minutes.
#'  If returnIntermediateTable is TRUE, a tibble, aggregated by day, with four columns:
#'    1. day:                    The day identifier.
#'    2. total_time_formatted:   The total time logged for that day.
#'    3. total_time_deficit:     Whether total_time_formatted is negative.
#'    4. target_duration:        The target duration for the day.
#' @export
#'
#' @importFrom rlang .data
#'
#' @examples
#' input <- yaml::read_yaml(text = "
#'   Total:
#'     deficit: no
#'     hours: 1
#'     minutes: 10
#'
#'   Days:
#'     Day 1:
#'       times:
#'         - -2M
#' ")
#' parse_times(input)
#'
#' \dontrun{
#' input <- yaml::read_yaml(file = "time_log.yaml")
#' parse_times(input)
#' }
parse_times <- function(times, returnIntermediateTable = FALSE) {
  new_total_yaml <- NULL

  if (!is.null(times$Days)) {
    parsed_data <- dplyr::tibble(
      day = character(),
      start_time = lubridate::period(),
      end_time = lubridate::period(),
      duration = double()
    )

    for (i in 1:length(times$Days)) {
      day_name <- names(times$Days[i])
      day_data <- times$Days[[i]]

      message('Processing day "', day_name, '"...')

      if (!is.null(day_data$times)) {
        for (datum in day_data$times) {
          data_to_add <- dplyr::tibble()
          start_and_end_time <- NULL

          if (grepl('^[-+]', datum)) {
            message('Processing "', datum, '" as duration.')
            is_negative = grepl('^-', datum)
            data_to_add <- dplyr::tibble(
              day = day_name,
              start_time = NA,
              end_time = NA,
              duration = ifelse(
                is_negative,
                -lubridate::as.duration(datum),
                lubridate::as.duration(datum)
              )
            )
          } else if (grepl('\\s*-\\s*', datum)) {
            message('Processing datum "', datum, '" as time range.')

            start_and_end_time <- utils::strcapture(
              pattern = "(.*)\\s*-\\s*(.*)",
              x = datum,
              proto = list(start = character(), end = character())
            )

            data_to_add <- dplyr::tibble(
              day = day_name,
              start_time = lubridate::hm(start_and_end_time$start),
              end_time = lubridate::hm(start_and_end_time$end),
              duration = lubridate::period(lubridate::period_to_seconds(.data$end_time) - lubridate::period_to_seconds(.data$start_time))
            )
          } else {
            warning('Not processing datum "', datum, '".')
          }

          if (data_to_add %>% nrow() > 0) {
            parsed_data <- parsed_data %>%
              tibble::add_row(
                data_to_add %>%
                  dplyr::mutate(
                    start_time = lubridate::as.period(.data$start_time),
                    end_time = lubridate::as.period(.data$end_time),
                    duration = as.double(.data$duration)
                  )
              )
          }
        }
      } else {
        message('No times to parse.')
      }
    }

    if (parsed_data %>% nrow() > 0) {
      chunked_data <- parsed_data %>%
        dplyr::group_by(.data$day) %>%
        dplyr::summarize(
          total_time = lubridate::as.period(sum(.data$duration)),
          target_duration = as.double(NA),
          .groups = "keep"
        ) %>%
        dplyr::ungroup()

      for (i in 1:nrow(chunked_data)) {
        row_data <- chunked_data[i, ]
        day <- row_data$day
        day_target_duration <- times$Days[[day]]$targetDuration

        row_data$target_duration <- ifelse(!is.null(day_target_duration), lubridate::as.duration(day_target_duration), lubridate::as.duration("0S"))

        chunked_data[i, ] <- row_data
      }

      if (returnIntermediateTable == TRUE) {
        message("Returning intermediate table...")
        return (
          chunked_data %>%
            dplyr::mutate(
              total_time = as.character(.data$total_time)
            ) %>%
            dplyr::transmute(
              day,
              total_time = lubridate::seconds_to_period(
                lubridate::as.period(.data$total_time)
              ),
              total_time_deficit = lubridate::as.period(.data$total_time) < 0,
              target_duration = lubridate::seconds_to_period(
                lubridate::as.period(.data$target_duration)
              ),
              target_duration_negative = lubridate::as.period(.data$target_duration) < 0,
            )
        )
      }

      summaryTable <- chunked_data %>%
        dplyr::mutate(
          adjusted_total_time = lubridate::as.period(ifelse(!is.na(.data$target_duration), .data$total_time - .data$target_duration, .data$total_time))
        ) %>%
        dplyr::summarize(
          total_duration = lubridate::as.duration(sum(.data$adjusted_total_time))
        ) %>%
        dplyr::mutate(
          total_in_seconds = as.numeric(.data$total_duration, 'seconds'),
          deficit = .data$total_in_seconds < 0,
          hours = as.integer(abs(.data$total_in_seconds %% 60)),
          minutes = as.integer(abs(.data$total_in_seconds / 60))
        ) %>%
        dplyr::select(
          .data$deficit,
          .data$hours,
          .data$minutes
        )

      starting_total <- lubridate::duration(ifelse(
        !is.null(times$Total$deficit) &&
          times$Total$deficit == TRUE,
        -lubridate::duration(times$Total$hours, units = "hours") - lubridate::duration(times$Total$minutes, units = "minutes"),
        lubridate::duration(times$Total$hours, units = "hours") + lubridate::duration(times$Total$minutes, units = "minutes")
      ))

      new_total <- dplyr::tibble(
        total_duration = lubridate::duration(ifelse(
          summaryTable$deficit == TRUE,
          starting_total - lubridate::duration(summaryTable$hours, units = "hours") - lubridate::duration(summaryTable$minutes, units = "minutes"),
          starting_total + lubridate::duration(summaryTable$hours, units = "hours") + lubridate::duration(summaryTable$minutes, units = "minutes")
        ))
      ) %>%
        dplyr::mutate(
          total_in_seconds = as.numeric(.data$total_duration, 'seconds'),
          deficit = .data$total_in_seconds < 0,
          hours = as.integer(floor(abs(.data$total_in_seconds / 60 / 60))),
          minutes = as.integer((abs(.data$total_in_seconds) / 60) %% 60)
        ) %>%
        dplyr::select(
          .data$deficit,
          .data$hours,
          .data$minutes
        )

      return(new_total)

      # new_total_yaml <- vector('character')
      # con <- textConnection('new_total_yaml', 'wr', local = TRUE)
      # sink(con)
      # list(Total = new_total) %>%
      #   yaml::write_yaml(stdout())
      # sink()
      #
      # new_total_yaml_text <- paste(c(new_total_yaml, '', 'Days:', '  '), collapse = '\n')
      # new_total_yaml_text %>%
      #   clipr::write_clip()
      # message('New total copied to clipboard.')
      # cat(new_total_yaml_text)
    } else {
      message('No data to parse for day.')
    }
  } else {
    message('No data to parse')
  }
}
